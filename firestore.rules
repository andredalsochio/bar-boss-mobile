rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helpers
    function isAuth() { return request.auth != null; }
    function isOwner(uid) { return isAuth() && request.auth.uid == uid; }

    function isBarMember(barId, uid) {
      return exists(/databases/$(database)/documents/bars/$(barId)/members/$(uid));
    }
    function isBarOwner(barId, uid) {
      return isBarMember(barId, uid) &&
             get(/databases/$(database)/documents/bars/$(barId)/members/$(uid)).data.role == 'OWNER';
    }

    // address: complement é opcional
    function validAddress(address) {
      return address is map
        && address.keys().hasAll(['cep','street','number','state','city'])
        && address.cep is string && address.cep.size() > 0
        && address.street is string && address.street.size() > 0
        && address.number is string && address.number.size() > 0
        && address.state is string && address.state.size() > 0
        && address.city is string && address.city.size() > 0;
        // complement opcional
    }

    // Validação mínima de bar no create/update
    function validBarCreate(data) {
      return data.keys().hasAll([
        'name','cnpj','responsibleName','contactEmail','contactPhone',
        'address','createdAt','createdByUid','primaryOwnerUid'
      ])
      && data.name is string && data.name.size() > 0
      && data.cnpj is string && data.cnpj.size() > 0
      && data.responsibleName is string && data.responsibleName.size() > 0
      && data.contactEmail is string && data.contactEmail.size() > 0
      && data.contactPhone is string && data.contactPhone.size() > 0
      && validAddress(data.address)
      && data.createdByUid == request.auth.uid
      && data.primaryOwnerUid == request.auth.uid;
    }

    function validMember(data) {
      return data.keys().hasAll(['uid','role','createdAt'])
        && data.uid is string && data.uid.size() > 0
        && data.role in ['OWNER','ADMIN','EDITOR'];
    }

    function validEvent(data) {
      return data.keys().hasAll(['title','startAt','published','createdAt','createdByUid'])
        && data.title is string && data.title.size() > 0
        && data.published is bool
        && (!('endAt' in data) || data.endAt >= data.startAt)
        && data.createdByUid == request.auth.uid;
    }

    // users
    match /users/{uid} {
      allow read: if isOwner(uid);
      allow create: if isOwner(uid);
      allow update: if isOwner(uid);
      // delete opcionalmente restrito ao próprio usuário
      allow delete: if isOwner(uid);
    }

    // bars
    match /bars/{barId} {
      // Leitura: somente membros do bar
      allow read: if isAuth() && isBarMember(barId, request.auth.uid);

      // Criação: usuário autenticado criando seu próprio bar
      allow create: if isAuth() && validBarCreate(request.resource.data);

      // Update: somente membros (opcional: restrinja certos campos ao OWNER)
      allow update: if isAuth() && isBarMember(barId, request.auth.uid) && validBarCreate(request.resource.data);

      // Delete: somente OWNER
      allow delete: if isAuth() && isBarOwner(barId, request.auth.uid);

      // bars/{barId}/members/{memberId}
    match /members/{memberId} {
      // Ler membro: o próprio membro autenticado pode ler (e isso habilita collectionGroup query por uid)
      allow read: if isAuth() && request.auth.uid == resource.data.uid;

        // Criar:
        // - No primeiro cadastro, permitir que o próprio usuário crie seu doc de membro com role OWNER
        // - Em outros casos, apenas OWNER pode incluir novos membros
        allow create: if isAuth() && (
          (request.resource.data.uid == request.auth.uid && request.resource.data.role == 'OWNER' && validMember(request.resource.data))
          || (isBarOwner(barId, request.auth.uid) && validMember(request.resource.data))
        );

        // Atualizar/Excluir: apenas OWNER do bar
        allow update: if isAuth() && isBarOwner(barId, request.auth.uid) && validMember(request.resource.data);
        allow delete: if isAuth() && isBarOwner(barId, request.auth.uid);
      }

      // bars/{barId}/events/{eventId}
      match /events/{eventId} {
        allow read: if isAuth() && isBarMember(barId, request.auth.uid);
        allow create: if isAuth() && isBarMember(barId, request.auth.uid) && validEvent(request.resource.data);
        allow update: if isAuth() && isBarMember(barId, request.auth.uid) && validEvent(request.resource.data);
        allow delete: if isAuth() && isBarMember(barId, request.auth.uid);
      }
    }

    // cnpj_registry — sem leitura pública; escrita pelo app autenticado (transação/batch)
    match /cnpj_registry/{cnpj} {
      allow read: if false;
      allow write: if isAuth();
    }

    // Collection group query para members
    match /{path=**}/members/{memberId} {
      allow read: if isAuth() && resource.data.uid == request.auth.uid;
    }
  }
}
